JVM探究
1.JVM的位置
2.JVM的体系结构
3.类加载器
    作用：加载class文件  new Student();
4.双亲委派机制 ：需要去学习 百度
5.沙箱安全机制
6.Native
7.PC寄存器
8.方法区
9.栈:栈内存，主管程序的运行，线程结束，栈内存也就释放，对于栈来说，不存在垃圾回收问题
  栈：先进后出，后进先出
  队列：先进先出(FIFO:First Input First Output)
  栈：8大基本类型+对象引用+实例的方法
  栈运行原理：栈帧
  栈满了：StackOverFlowError
  要了解 栈具体怎么存的东西
  要画出一个对象实例化的过程
10.三种JVM
    1.Sun公司 Java HotSpot(TM) 64-Bit Server VM (build 25.281-b09, mixed mode)
    2.BEA JRockit
    3.IBM J9 VM
11.堆 (Heap)
一个JVM只有一个堆，堆内存的大小是可以调节的
类加载器读取了类文件后，一般会把什么东西放到堆中呢？类，方法，常量，变量~，保存我们所有引用类型的真实对象
堆内存中还要细分为三个区域：
新生区(伊甸园区) Young/New   (Eden Space,幸存0区,幸存1区)
老年区 old
永久区 Perm（jdk1.8之后移除永久区）

假设堆内存满了，OOM，堆内存不够！ java.lang.OutOfMemoryError:Java heap space
在JDK8以后，永久存储区改了个名字（元空间）;
12.新生区,老年区
新生区: 类诞生和成长的地方， 甚至死亡
伊甸园，所有的对象都是在伊甸园区new出来的， 满了会触发一次轻GC（垃圾回收）,活下来的移到幸存0区
幸存者区（0,1）如果幸存区0,1都满了触发一次重GC(Full GC)，活下来的进入养老区
养老区再满了就OOM
真理：经过研究，99%的对象都是临时对象！
13.永久区
这个区域常驻内存的，用来存放JDK自身携带的Class对象，包括Interface元数据，存储的是Java运行时的一些环境或类信息。
这个区域不存在垃圾回收！关闭JVM虚拟机就会释放这个区域的内存
一个启动类加载了大量的第三方jar包或者tomcat部署了太多的应用，大量动态生成的反射类。不断的被加载知道内存满就出现OOM
  jdk1.6之前：永久代,常量池在方法区中
  jdk1.7   ：永久代，但是慢慢退化了，去永久代，常量池在堆中
  jdk1.8之后：无永久代，常量池在元空间
14.堆内存调优
15.GC  垃圾回收器
    常用算法
16.JMM
17.总结

JVM在进行GC时，并不是对这三个区域统一回收，大部分时候，回收的是新生代
新生区
幸存区（from to）
老年区

GC两种类： 轻GC  ，重GC（全局GC fullGC ）

GC题目：
JVM的内存模型和分区 详细到每个区放什么
堆里面有哪些？ Eden from to 老年区
GC的算法有哪些？标记清除算法，标记整理算法（标记压缩），复制算法，分代收集算法
引用计数法应该与可达性分析归（GC ROOT）为一类

复制算法
新生代
1.每次GC都会将Eden活的对象移到幸存区中，一旦Eden区被GC后，就会是空的
2.
谁空谁是to区
当一个对象在 FROM TO区经历了15次GC都还没有死，就到了老年区，默认15次。
这个也可以调 -XX:MaxTenuringThreshold=5 通过这个参数可以设定进入老年代的时间

好处：没有内存碎片
坏处：浪费了内存空间，多了一般空间永远是空to
复制算法最佳使用场景：对象存活度较低的时候，新生区

标记清除算法
优点：不需要额外的空间
缺点：两次扫描，严重浪费时间，会产生内存碎片
标记压缩
防止内存碎片产生，是在标记清除算法上再次扫描，向一端移动存活的对象

内存效率：复制算法>标记清除算法>标记压缩算法（时间复杂度）
内存整齐度：复制算法=标记压缩算法>标记清除算法
内存利用率：标记压缩算法=标记清除算法>复制算法

思考一个问题，难道没有最优算法吗？
答案：没有，没有最好的算法，只有最合适的算法---》GC：分代收集算法

年轻代： 存活率低  复制算法
老年代： 标记清除+标记压缩混合实现

JMM(Java Memory Model)
1.他是干嘛的？ 搜索其他人的视频
作用：缓存一致性协议，用于定义数据读写的规则
2.它该如何学习
从抽象的角度来看，JMM定义了线程工作内存和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，
每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。
本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。



