JVM探究
1.JVM的位置
2.JVM的体系结构
3.类加载器
    作用：加载class文件  new Student();
4.双亲委派机制 ：需要去学习 百度
5.沙箱安全机制
6.Native
7.PC寄存器
8.方法区
9.栈:栈内存，主管程序的运行，线程结束，栈内存也就释放，对于栈来说，不存在垃圾回收问题
  栈：先进后出，后进先出
  队列：先进先出(FIFO:First Input First Output)
  栈：8大基本类型+对象引用+实例的方法
  栈运行原理：栈帧
  栈满了：StackOverFlowError
  要了解 栈具体怎么存的东西
  要画出一个对象实例化的过程
10.三种JVM
    1.Sun公司 Java HotSpot(TM) 64-Bit Server VM (build 25.281-b09, mixed mode)
    2.BEA JRockit
    3.IBM J9 VM
11.堆 (Heap)
一个JVM只有一个堆，堆内存的大小是可以调节的
类加载器读取了类文件后，一般会把什么东西放到堆中呢？类，方法，常量，变量~，保存我们所有引用类型的真实对象
堆内存中还要细分为三个区域：
新生区(伊甸园区) Young/New   (Eden Space,幸存0区,幸存1区)
老年区 old
永久区 Perm（jdk1.8之后移除永久区）

假设堆内存满了，OOM，堆内存不够！ java.lang.OutOfMemoryError:Java heap space
在JDK8以后，永久存储区改了个名字（元空间）;
12.新生区,老年区
新生区: 类诞生和成长的地方， 甚至死亡
伊甸园，所有的对象都是在伊甸园区new出来的， 满了会触发一次轻GC（垃圾回收）,活下来的移到幸存0区
幸存者区（0,1）如果幸存区0,1都满了触发一次重GC(Full GC)，活下来的进入养老区
养老区再满了就OOM
真理：经过研究，99%的对象都是临时对象！
13.永久区
这个区域常驻内存的，用来存放JDK自身携带的Class对象，包括Interface元数据，存储的是Java运行时的一些环境或类信息。
这个区域不存在垃圾回收！关闭JVM虚拟机就会释放这个区域的内存
一个启动类加载了大量的第三方jar包或者tomcat部署了太多的应用，大量动态生成的反射类。不断的被加载知道内存满就出现OOM
  jdk1.6之前：永久代,常量池在方法区中
  jdk1.7   ：永久代，但是慢慢退化了，去永久代，常量池在堆中
  jdk1.8之后：无永久代，常量池在元空间
14.堆内存调优
15.GC  垃圾回收器
    常用算法
16.JMM
17.总结